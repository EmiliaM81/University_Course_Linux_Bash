<html>
  <head>
    <title>Programy i procesy</title>
    <meta http-equiv="Content-type" content="text/html; charset=iso-8859-2" />
    <link rel="stylesheet" href="userguide.css" type="text/css" />

  </head>

  <body>
  <div class="nav">
  <table class="nav">
  <tr>
  <td><a href="index.html">Wstêp</a></td>
  <td><a href="Hasla.html">Konta i has³a</a></td>
  <td><a href="Pliki.html">Pliki i systemy plików</a></td>
  <td>Programy i procesy</td>
  <td><a href="Siec.html">Sieæ i praca zdalna</a></td>
  <td><a href="Linki.html">Zobacz te¿...</a></td>
  </tr>
  </table>
  </div> <!-- nav -->
  <div class="section">
  <h2>Programy i procesy</h2>
  <div class="subsection">
  <p>
  Uruchamianie programów jest podstawow± czynno¶ci± wykonywan± przez u¿ytkownika komputera; warto wiêc
  od pocz±tku zrozumieæ parê pojêæ z tym zwi±zanych.
  </p>
  <p>
  <strong>Program</strong> rozumiemy tu jako <em>plik wykonywalny</em>, a wiêc taki, który system potrafi
  <em>uruchomiæ</em>, np. w reakcji na dzia³anie u¿ytkownika.  Dzia³aniem tym mo¿e byæ np. wypisanie nazwy
  tego pliku w linii komend <em>shella</em> (interpretera komend) lub (w ¶rodowisku okienkowym) klikniêcie
  na ikonê powi±zan± z danym programem.
  </p>
  <p>
  <strong>Procesem</strong> z kolei jest instancja dzia³aj±cego programu, która powsta³a w wyniku jego
  uruchomienia.  W danej chwili mo¿e istnieæ i dzia³aæ wiele ró¿nych procesów, bêd±cych wynikiem
  uruchomienia tak tego samego, jak i ró¿nych programów, przez wielu ró¿nych u¿ytkowników.  Dlatego
  m. in. nale¿y rozró¿niaæ pomiêdzy procesem a programem.  Ka¿dy proces posiada przydzielony przez
  system, jednoznaczny (w danej chwili czasu) numeryczny identyfikator (<em>PID</em>) i wykonuje siê
  w zasadzie niezale¿nie od innych procesów, dzia³aj±cych na tym samym komputerze; mo¿e siê jednak
  z nimi komunikowaæ, za po¶rednictwem ca³ego szeregu mechanizmów <em>komunikacji miêdzyprocesowej</em>
  zapewnionych przez system operacyjny.
  </p>
  </div> <!-- subsection -->
  <h3>Programy</h3>
  <div class="subsection">
  <p>
  Aby plik móg³ byæ uruchomiony jako program, musz± byæ spe³nione dwa warunki:
  </p>
  <ul>
  <li>
  U¿ytkownikowi uruchamiaj±cemu program musi przys³ugiwaæ prawo do uruchamiania danego pliku
  </li>
  <li>
  Zawarto¶æ pliku musi byæ odpowiednia.
  </li>
  </ul>
  <p>
  Pierwszy warunek zosta³ omówiony w <a href="Pliki.html">rozdziale o plikach</a>; drugi warunek jest
  spe³niony, gdy plik programu powsta³ w wyniku <em>kompilacji</em> i <em>linkowania</em> kodu ¼ród³owego
  (napisanego w jakim¶ jêzyku programowania, takim jak C, Fortran, Pascal, ...) przez odpowiedni
  kompilator (mówimy wówczas o programie binarnym).  Jest on spe³niony równie¿, je¿eli plik zawiera
  tekst instrukcji w jêzyku interpretowanym (takim jak jêzyk shella <code>sh</code>, Perl, Python, ...),
  program interpretuj±cy ten jêzyk jest w³a¶ciwie zainstalowany na systemie, a tre¶æ pierwszej linijki
  pliku zbudowana jest wed³ug wzoru
  <blockquote><code>
  	#! /bin/sh
  </code></blockquote>
  </p><p>
  tj. zawiera jako dok³adnie dwa pierwsze znaki sekwencjê <code>#!</code>, a po nich nastêpuje
  <em>pe³na ¶cie¿ka dostêpu</em> do programu interpretuj±cego.  Taki program nazywa siê czêsto
  <em>skryptem</em>.
  </p>
  <p>
  Programy binarne przeznaczone do wspólnego u¿ytku zainstalowane s± w katalogach ogólnosystemowych,
  takich jak <code>/bin</code> (programy niezbêdne do uruchomienia systemu), <code>/usr/bin</code>
  (wiêkszo¶æ narzêdzi przeznaczonych dla u¿ytkowników), <code>/usr/local/bin</code> (programy spoza
  ,,oficjalnej" zawarto¶ci systemu operacyjnego), <code>/usr/X11R6/bin</code> (programy zwi±zane
  ze ¶rodowiskiem okienkowym <em>X Window System</em>), <code>/usr/dt/bin</code> (programy zwi±zane
  ze ¶rodowiskiem graficznym <em>CDE</em> stosowanym w systemie Sun Solaris).  Ka¿dy plik spe³niaj±cy
  warunki opisane powy¿ej mo¿e byæ jednak uruchomiony (niezale¿nie od jego lokalizacji) poprzez podanie
  w linii komend specyfikacji ¶cie¿ki dostêpu (zamiast tylko nazwy pliku); np. uruchomienie programu
  o nazwie np. <code>mojprog</code> znajduj±cego siê w katalogu aktualnym (nie bêd±cym jednym z
  katalogów systemowych) wymaga na ogó³ podania komendy w postaci
  <blockquote><code>
  ./mojprog
  </code></blockquote>
  </p>
  <p>
  Nazwa uruchamianego pliku jest generalnie bez znaczenia, w szczególno¶ci Unix nie przywi±zuje wagi
  do tzw. koñcówki nazwy programu (nie spotyka siê programów zapisanych w plikach o nazwach koñcz±cych
  siê na <code>.EXE</code>, <code>.BAT</code> czy <code>.COM</code>).
  </p>
  </div> <!-- subsection -->
  <h3>Procesy i interpreter komend</h3>
  <div class="subsection">
  <p>
  Najprostszym sposobem stworzenia procesu przez u¿ytkownika jest uruchomienie (legalnego) pliku
  wykonywalnego, przez podanie jego nazwy (lokalizacji) w linii komend.  W wielu przypadkach,
  w zale¿no¶ci od uruchamianego programu mo¿na te¿ (lub nale¿y) podaæ opcje dla programu oraz
  argumenty -- bêd±ce czêsto (choæ nie zawsze) nazwami plików które maj± byæ przetworzone. Dla wiêkszo¶ci
  programów obowi±zuje zasada, ¿e bezpo¶rednio po nazwie (lokalizacji) programu podajemy ew. opcje
  uruchomienia; maj± one najczê¶ciej postaæ skrótów jednoliterowych poprzedzonych znakiem <code>-</code>
  (minus), np. <code>ls -l</code>, przy czym w wypadku podawania kilku opcji jednocze¶nie mo¿na
  je grupowaæ: np. zamiast <code>ls -l -A</code> mo¿na równowa¿nie napisaæ <code>ls -lA</code>.
  Ewentualne argumenty podawane s± po opcjach, np. <code>ls -Al /tmp</code>.
  </p>
  <p>
  Nale¿y wiedzieæ, ¿e zawarto¶æ linii komend podlega pewnej interpretacji i ,,obróbce'' przez shell
  (interpreter komend) zanim opcje i argumenty zostan± przekazane uruchomionemu programowi.  W du¿ym
  uproszczeniu: tre¶æ linii komend jest dzielona na ,,s³owa'' (sekwencje znaków oddzielone ci±gami
  spacji), i ka¿de ,,s³owo'' bêdzie potraktowane jako oddzielny argument (lub grupa opcji); po czym
  nastêpuje interpretacja pewnych znaków specjalnych (metaznaków).  Przytoczê tu jedynie najprostsze
  (i najczê¶ciej przydatne) przyk³ady zastosowania rozwiniêæ metaznaków:
  <ul>
     <li>znaki <code>*</code>, <code>?</code> oraz sekwencje postaci <code>[...]</code> stosowane s±
     do tworzenia <em>wzorców nazw plików</em>; w takim wzorcu, <code>*</code> zastêpuje <em>dowolny
     ci±g (zera lub wiêcej) znaków</em>, <code>?</code> <em>dowolny (ale dok³adnie jeden) znak</em>,
     np. <code>[bpdt]</code> <em>dowolny pojedynczy znak spo¶ród wymienionych</em> (a wiêc tu: b, p, d lub t),
     np. <code>[b-k]</code> <em>dowolny pojedynczy znak z podanego zakresu</em> (tu: od b do k).  Zakres znaków
     wyznaczony jest tu przez zakres warto¶ci ich kodów ASCII; warto wiêc wiedzieæ, ¿e w kodowaniu
     ASCII wszystkie cyfry wystêpuj± w porz±dku (0-9), poprzedzaj±c wszystkie wielkie litery (A-Z),
     wystêpuj±ce w porz±dku alfabetycznym, które z kolei poprzedzaj± wszystkie ma³e litery (a-z),
     równie¿ wystêpuj±ce w porz±dku alfabetycznym.  Bezpo¶rednio po znaku <code>[</code>, znak <code>^</code>
     ma znaczenie dope³nienia (podanego zbioru lub zakresu znaków), tak np. <code>[^a-z]</code>
     oznacza dowolny znak <em>nie</em> bed±cy ma³± liter±.<br />
     Interpretacja tak utworzonych wzorców polega na ich zast±pieniu przez listê nazw istniej±cych plików,
     pasuj±cych do podanego wzorca.  Znak separatora katalogów (<code>/</code>) nie jest nigdy
     wynikiem rozwiniêcia, tzn. wynikiem interpretacji wzorca nie zawieraj±cego znaku <code>/</code>
     mog± byæ wy³±cznie nazwy plików z katalogu aktualnego.  Mo¿na jednak tworzyæ równie¿ wzorce
     zawieraj±ce <code>/</code>; bêd± one interpretowane zgodnie z ogólnymi regu³ami specyfikowania lokalizacji
     plików (p. <a href="Pliki.html">Pliki i systemy plików</a>).
     </li>
     <li>,,S³owa'' zaczynaj±ce siê od znaku tyldy (<code>~</code>) interpretowane s± jako katalog
     ,,domowy'' aktualnego u¿ytkownika (sam znak <code>~</code> lub sekwencja <code>~/</code>), lub
     jako katalog ,,domowy'' u¿ytkownika o nazwie (loginie) która nastêpuje po <code>~</code>, np.
     <code>~rjb</code>: ¶cie¿ka do katalogu domowego u¿ytkownika <code>rjb</code>. Znak <code>~</code>
     wystêpuj±cy w pozycji innej ni¿ na pocz±tku s³owa nie podlega specjalnej interpretacji.
     </li>
     <li>
     Sekwencja rozpoczynaj±ca siê od znaku <code>$</code> zastêpowana jest przez warto¶æ zmiennej shella,
     której nazwa nastêpuje po <code>$</code>; np. polecenie <code>echo $PATH</code> wypisuje aktualn±
     warto¶æ zmiennej <code>PATH</code> (a nie napis <code>$PATH</code>).
     </li>
     <li>
     Znaki <code>"</code>, <code>'</code> (cudzys³ów i apostrof) oraz <code>\</code> s³u¿± do ,,ochrony''
     innych metaznaków przed interpretacj± przez shell, w przypadku gdy powinny one byæ przekazane
     do uruchamianego programu w postaci dos³ownej. Znak <code>\</code> ,,chroni'' znak po nim nastêpuj±cy;
     para apostrofów <code>'...'</code> zapobiega interpretacji wszelkich metaznaków (z wyj±tkiem samego apostrofu);
     para cudzys³owów <code>"..."</code> ,,chroni'' spacje i metaznaki tworz±ce wzorce nazw plików,
     natomiast nie zapobiega interpretacji znaku <code>$</code>.
     </li>
  </ul>
  <p>
    Inny u¿yteczny trik to <code>komenda1 `komenda2`</code>, dzia³a on nastêpuj±co: jako pierwsza zostanie wykonana
    <code>komenda2</code> (mo¿e ona oczywi¶cie zawieraæ równie¿ argumenty), wynik jej wykonania -- to, co normalnie
    pojawi³oby siê na ekranie, tj. zawarto¶æ standardowego strumienia wyj¶ciowego -- zostanie umieszczony
    w linii komend wywo³uj±cej <code>komenda1</code>, która nastêpnie zostanie wykonana (z zastosowaniem
    pozosta³ych regu³ rozwijania).
  </p>
  <p>
    Shell umo¿liwia równie¿ edycjê linii komend, oraz odwo³ywanie siê do komend wpisanych uprzednio (klawisz
    ,,strza³ka w górê''), z mo¿liwo¶ci± ich edycji (modyfikacji) przed ponownym wykonaniem. W¶ród innych
    udogodnieñ u³atwiaj±cych pracê interakcyjn± warto wymieniæ tzw. autouzupe³nianie (nazw komend i argumentów);
    w szczegó³ach jego dzia³anie ró¿ni siê w zale¿no¶ci od u¿ywanej wersji shella i opcji konfiguracyjnych,
    ale zazwyczaj pozwala ono na u¿ycie klawisza ,,Tab'' po wpisaniu czê¶ci nazwy komendy, lub nazwy pliku
    maj±cej byæ argumentem, czego wynikiem jest uzupe³nienie tej nazwy o dalsze znaki na tyle, na ile jest
    to jednoznacznie mo¿liwe (tj. je¿eli do pocz±tkowych kilku znaków pasuje nazwa tylko jednego faktycznie
    istniej±cego pliku, to pojawi siê ona na linii komend w ca³o¶ci).
  </p>
  <p>
    W istocie shell jest interpreterem do¶æ zaawansowanego jêzyka programowania, potrafi±cym wykonywaæ programy
    bezpo¶rednio z plików tekstowych, zwanych skryptami shella.  Jêzyk ten zawiera w zasadzie wszystkie
    elementy przydatne do tworzenia nawet do¶æ rozbudowanych programów (zmienne, pêtle, instrukcje warunkowe,
    mo¿liwo¶æ definicji funkcji ...); bardziej szczegó³owe jego omówienie wykracza jednak poza zakres
    niniejszych notatek.  Wspomnê jedynie, ¿e sk³adnia jêzyka shella ró¿ni siê do¶æ istotnie w zale¿no¶ci
    od typu shella; u¿ywany jako domy¶lny do pracy interakcyjnej w naszej sieci <code>tcsh</code> nie jest
    szczególnie godny polecenia (w do¶æ powszechnej opinii) do tworzenia bardziej rozbudowanych skryptów;
    do tego celu zazwyczaj u¿ywa siê bardziej standardowego <code>sh</code>, lub bêd±cego domy¶lnym
    w wiêkszo¶ci instalacji Linuxa shella <code>bash</code>.
  </p>
  <p>
    Z bardziej zaawansowanych w³a¶ciwo¶ci shella omówiê tu pobie¿nie jedynie dwie: kontrolê zadañ, oraz
    przekierowania i potoki.  Kontrola zadañ stwarza mo¿liwo¶æ uruchamiania procesów ,,w tle'', tj. z natychmiastowym
    powrotem do shella i mo¿liwo¶ci± wydawania kolejnych poleceñ bez czekania na zakoñczenie uruchomionego
    w³a¶nie procesu, ,,zawieszania'' wykonania aktualnie dzia³aj±cego procesu oraz ¿onglowania na rozmaite
    sposoby grup± zadañ uruchomionych z aktualnej instancji shella.  Jest to szczególnie przydatne
    w przypadku uruchamiania d³ugotrwa³ych procesów, które wykonuj± siê bez potrzeby interakcji z u¿ytkownikiem,
    oraz przy uruchamianiu programów które np. tworz± w³asne okna graficzne i poprzez nie komunikuj± siê
    interakcyjnie z u¿ytkownikiem.  Uruchomienie procesu w tle dokonuje siê przez zakoñczenie linii komend
    znakiem <code>&</code>, postawionym po wszystkich argumentach do polecenia i ew. przekierowaniach
    (p. poni¿ej).  Do ,,zawieszenia'' procesu aktualnie dzia³aj±cego ,,w pierwszym planie'' s³u¿y zazwyczaj
    sekwencja klawiszy <code>Ctrl-z</code>; w odró¿nieniu od procesu uruchomionego ,,w tle'', proces
    zawieszony wstrzymuje dzia³anie i czeka na ewentualne ,,odwieszenie''.  Listê zadañ zwi±zanych z aktualnym
    shellem (zawieszonych i uruchomionych w tle) mo¿na obejrzeæ komend± <code>jobs</code>; ka¿de zadanie
    z tej listy bêdzie opatrzone numerem identyfikacyjnym, z którego mo¿na skorzystaæ do wydawania poleceñ
    zmieniaj±cych stan danego zadania.  Polecenie <code>fg %n</code> (gdzie <code>n</code> jest tym numerem
    identyfikacyjnym) przenosi dane zadanie do ,,pierwszego planu'', zarazem je wznawiaj±c (o ile by³o ono
    zatrzymane); natomiast <code>bg %n</code> wznawia wykonywanie zadania zawieszonego, pozostawiaj±c je
    ,,w tle''.
  </p>
  <p>
    Mechanizm przekierowania i potoków pozwala z kolei na proste wykonywanie nawet do¶æ z³o¿onych operacji
    przetwarzania danych poprzez ³±czenie w ,,³añcuszek'' szeregu prostych komend, z których ka¿da wykona
    jeden z etapów przetwarzania przekazuj±c wynik nastêpnej w celu wykonania koleknek operacji.  Korzysta
    tu siê z faktu, ¿e z ka¿dym procesem unixowym zwi±zane s± trzy tzw. standardowe strumienie wej¶cia-wyj¶cia:
    standardowe wej¶cie (<code>stdin</code>), standardowe wyj¶cie (<code>stdout</code>) i standardowy
    strumieñ b³êdu (<code>stderr</code>).  Domy¶lnie, <code>stdin</code> uto¿samiony jest z klawiatur±
    terminala, a <code>stdout</code> i <code>stderr</code> -- z ekranem.  Tzn. np. ¿e dane wyprowadzone
    przez program na <code>stdout</code> pojawi± siê na ekranie u¿ytkownika.  Wiêkszo¶æ standardowych
    programów narzêdziowych, stanowi±cych podstawowe wyposa¿enie systemu unixowego, potrafi czytaæ dane
    wej¶ciowe zarówno z plików (z dysku), jak i ze strumienia <code>stdin</code>, natomiast wyniki przetwarzania
    wyprowadza domy¶lnie na strumieñ <code>stdout</code>.  Strumieñ <code>stderr</code> s³u¿y natomiast
    do wypisywania komunikatów nie bêd±cych ,,normalnym'' wynikiem przetwarzania danych, tj. komunikatów
    o b³êdach i ew. ostrze¿eñ o sytuacjach mniej lub bardziej ,,anomalnych''.
  </p>
  <blockquote><font="-1">
    Dla przyk³adu, komenda <code>sort</code> s³u¿y do sortowania (domy¶lnie: alfabetycznego) linijek tekstu
    stanowi±cych dane wej¶ciowe. Gdy siê j± wywo³a z argumentami bêd±cymi nazwami plików, danymi do sortowania
    bêdzie zawarto¶æ tych¿e; w przypadku wywo³ania bez argumentów (nie bêd±cych opcjami, za pomoc± których
    mo¿na zadaæ bardziej z³o¿one kryteria sortowania), komenda <code>sort</code> oczekuje, ¿e dane
    do przetworzenia pojawi± siê w standardowym strumieniu wej¶ciowym.  W obu tych przypadkach, wynik
    sortowania pojawi siê na <code>stdout</code>.
  </font></blockquote>
  <p>
    Mechanizm o którym mowa polega na udostêpnieniu mo¿liwo¶ci przedefiniowania standardowych strumieni, na dwa
    sposoby: b±d¼ przez po³±czenie ich z plikami, b±d¼ przez po³±czenie <code>stdout</code> jednego procesu
    z <code>stdin</code> innego.  Konstrukcja <code>komenda ... > plik</code> powoduje, ¿e zawarto¶æ
    <code>stdout</code> wywo³anej komendy, zamiast na ekranie, pojawi siê w pliku o podanej nazwie (w miejscu
    wielokropka umie¶ciæ mo¿na dowolne opcje i inne argumenty wywo³ania); podobnie <code>komenda ... &lt; plik</code>
    spowoduje, ¿e zawarto¶æ podanego pliku bêdzie stanowi³a <code>stdin</code> wywo³anej komendy.  Z kolei
    pisz±c <code>komenda1 ... | komenda2 ...</code> sprawimy, ¿e dane wyprowadzone przez <code>komenda1</code>
    na <em>jej</em> <code>stdout</code> stan± siê zawarto¶ci± <code>stdin</code> dla <code>komenda2</code>.
    Wszystkich tych rodzajów przekierowania mo¿na te¿ u¿yæ ³±cznie, np.:
    <code>komenda1 &lt; plik1 | komenda2 > plik2</code>.
  </p>
    <strong>Uwagi:</strong>
    <ul>
    <li>
      Je¶li zastosujemy przekierowanie <code>komenda .. > plik</code>, a <code>plik</code> ju¿ istnieje,
      to jego wcze¶niejsza zawarto¶æ zostanie zast±piona przez zawarto¶æ <code>stdout</code> wywo³anej
      komendy -- tj. utracona!  Istnieje druga postaæ przekierowania <code>stdout</code>:
      <code>komenda ... >> plik</code>, przy której zawarto¶æ <code>stdout</code> wywo³anej komendy nie
      zastêpuje ew. wcze¶niejszej zawarto¶ci podanego pliku, lecz zostanie dopisana do jej koñca.
    </li>
    <li>
      Przekierowanie <code>stdout</code> nie ma wp³ywu na powi±zanie <code>stderr</code> z ekranem,
      komunikaty o b³êdach pojawi± siê i tak na ekranie terminala u¿ytkownika.  Wiêkszo¶æ narzêdzi
      unixowych nie wypisuje ¿adnych komunikatów w przypadku, gdy ich dzia³anie przebiega zgodnie
      z oczekiwaniami.
    </li>
    <li>
      Przekierowanie potokowe mo¿e byæ równie¿ zastosowane wielokrotnie w ramach jednej komendy z³o¿onej,
      np. <code>komenda1 ... | komenda2 ... | komenda3 ...</code>.  Shell nie czeka z uruchomieniem
      kolejnych poleceñ wystêpuj±cych w potoku przetwarzania na zakoñczenie poprzednich, bêd± one
      dzia³a³y równolegle w miarê nap³ywania danych.
    </li>
    </ul>
  </div> <!-- subsection -->
    <blockquote>Czytane <accessed type="number"/> razy.</blockquote>
  </div> <!-- section -->
  </body>
</html>
